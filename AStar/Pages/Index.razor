@page "/"

@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using System.Text;
@inject IJSRuntime JsRuntime;

<div @onclick="OnTileClicked" @onmousemove="OnTileHovered">
    <BECanvas Width="@(MAP_WIDTH * TILE_SIZE)" Height="@(MAP_HEIGHT * TILE_SIZE)" @ref="_canvasReference"></BECanvas>
</div>

<button @onclick="OnSetStartClicked">Set Start</button>
<button @onclick="OnSetGoalClicked">Set Goal</button>
<button @onclick="OnRunClicked">Run</button>
<button @onclick="OnStepClicked">Step</button>
<button @onclick="OnRunClicked">Partial Step</button>

<textarea readonly rows="6">@TileInformation</textarea>


@code {
    private const int TILE_SIZE = 24;

    private const int MAP_WIDTH = 20;
    private const int MAP_HEIGHT = 20;

    private const string STYLE_START = "red";
    private const string STYLE_GOAL = "green";

    private const string STYLE_PASSABLE = "ghostwhite";
    private const string STYLE_WALL = "blue";

    private const string STYLE_FRONTIER = "yellow";
    private const string STYLE_NEXT = "orange";
    private const string STYLE_EXPANDED = "darkgoldenrod";

    public string TileInformation { get; set; } = "";


    private Canvas2DContext _context;
    protected BECanvasComponent _canvasReference;

    private World.Map _map;

    private bool _settingStart;
    private bool _settingGoal;

    private (int x, int y) _start = (-1, -1);
    private (int x, int y) _goal = (-1, -1);

    private Pathing.AStar<World.Tile>? _aStar;

    private StringBuilder _informationBuilder = new StringBuilder();


    private void OnRunClicked()
    {
        RecreateAStar();

        while (_aStar != null && !_aStar.GoalReached)
        {
            StepAStar();
        }
    }

    private void OnStepClicked()
    {
        RecreateAStar();
        StepAStar();
    }

    private void RecreateAStar()
    {
        if(_aStar == null && _start.x != -1 && _start.y != -1 && _goal.x != -1 && _goal.y != -1)
        {
            _aStar = new Pathing.AStar<World.Tile>(_map.Heuristic, _map.ExpandTile, _map.GetTileAt(_start.x, _start.y), _map.GetTileAt(_goal.x, _goal.y));
        }
    }

    private void StepAStar()
    {
        if(_aStar == null)
        {
            return;
        }
        var nextTile = _aStar.CurrentState.Next?.Data;
        if(nextTile != null)
        {
            _map.GetTileAt(nextTile.Value.X, nextTile.Value.Y).IsNext = false;
        }

        foreach (var frontierItem in _aStar.CurrentState.PriorityQueue.UnorderedItems)
        {
            var tile = frontierItem.Element.Data;
            _map.GetTileAt(tile.X, tile.Y).OnFrontier = false;
        }

        foreach (var expandedItem in _aStar.CurrentState.Expanded)
        {
            var tile = expandedItem.Data;
            _map.GetTileAt(tile.X, tile.Y).IsExpanded = false;
        }

        _aStar.Step();

        nextTile = _aStar.CurrentState.Next?.Data;
        if(nextTile != null)
        {
            _map.GetTileAt(nextTile.Value.X, nextTile.Value.Y).IsNext = true;
        }

        foreach (var frontierItem in _aStar.CurrentState.PriorityQueue.UnorderedItems)
        {
            var tile = frontierItem.Element.Data;
            _map.GetTileAt(tile.X, tile.Y).OnFrontier = true;
        }

        foreach (var expandedItem in _aStar.CurrentState.Expanded)
        {
            var tile = expandedItem.Data;
            _map.GetTileAt(tile.X, tile.Y).IsExpanded = true;
        }


        foreach(var node in _aStar.SearchTree.Nodes)
        {
            _map.GetTileAt(node.Data.X, node.Data.Y).HeuristicCost = node.HeuristicCost;
            _map.GetTileAt(node.Data.X, node.Data.Y).TotalCost = node.TotalCost;
        }

        StateHasChanged();
    }

    private void OnSetStartClicked()
    {
        _settingStart = !_settingStart;
    }

    private void OnSetGoalClicked()
    {
        _settingGoal = !_settingGoal;
    }

    private void OnTileClicked(MouseEventArgs e)
    {
        int x = (int)(e.OffsetX / TILE_SIZE);
        int y = (int)(e.OffsetY / TILE_SIZE);

        if(x < 0 || x > MAP_WIDTH || y < 0 || y > MAP_HEIGHT)
        {
            return;
        }

        if(_settingStart)
        {
            _start = (x, y);
            _settingStart = false;
        }
        else if(_settingGoal)
        {
            _goal = (x, y);
            _settingGoal = false;
        }
        else
        {
            _map.GetTileAt(x, y).Passable = !_map.GetTileAt(x, y).Passable;
        }

        _aStar = null;
    }

    private void OnTileHovered(MouseEventArgs e)
    {

        int x = (int)(e.OffsetX / TILE_SIZE);
        int y = (int)(e.OffsetY / TILE_SIZE);

        if(x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT)
        {
            return;
        }

        var tile = _map.GetTileAt(x, y);
        _informationBuilder.Clear();
        _informationBuilder.AppendLine($"Tile @ ({x}, {y})");
        _informationBuilder.AppendLine($"Cost (f(n)): {tile.TotalCost}");
        _informationBuilder.AppendLine($"Heuristic (h(n)): {tile.HeuristicCost}");
        
        if (tile.IsNext)
        {
            _informationBuilder.AppendLine($"Up next");
        }
        else if(tile.IsExpanded)
        {
            _informationBuilder.AppendLine($"Expanded");
        }
        else if (tile.OnFrontier)
        {
            _informationBuilder.AppendLine($"On frontier");
        }

        TileInformation = _informationBuilder.ToString();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if(firstRender)
        {
            _map = new World.Map(MAP_WIDTH, MAP_HEIGHT);
        }
        this._context = await this._canvasReference.CreateCanvas2DAsync();
        await Draw();
    }

    private async Task Draw()
    {
        await this._context.SetStrokeStyleAsync("silver");
        for (int x = 0; x < _map.Width; x++)
        {
            for (int y = 0; y < _map.Height; y++)
            {
                var tile = _map.GetTileAt(x, y);

                if(tile.Passable)
                {
                    if (_start.x == x && _start.y == y)
                    {
                        await this._context.SetFillStyleAsync(STYLE_START);
                    }
                    else if (_goal.x == x && _goal.y == y)
                    {
                        await this._context.SetFillStyleAsync(STYLE_GOAL);
                    }
                    else if (tile.IsExpanded)
                    {
                        await this._context.SetFillStyleAsync(STYLE_EXPANDED);
                    }
                    else if (tile.IsNext)
                    {
                        await this._context.SetFillStyleAsync(STYLE_NEXT);
                    }
                    else if (tile.OnFrontier)
                    {
                        await this._context.SetFillStyleAsync(STYLE_FRONTIER);
                    }
                    else
                    {
                        await this._context.SetFillStyleAsync(STYLE_PASSABLE);
                    }
                }
                else
                {
                    await this._context.SetFillStyleAsync(STYLE_WALL);
                }


                await this._context.FillRectAsync(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                await this._context.StrokeRectAsync(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }
    }
}