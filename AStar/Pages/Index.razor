@page "/"

@using AStar.World;
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using System.Text;
@using Pathing;
@using System.Diagnostics.CodeAnalysis;
@inject IJSRuntime JsRuntime;
@using Blazorise


<Alert Color="Color.Success" @bind-Visible="@GoalReached">
    <AlertMessage>Goal reached!</AlertMessage>
    <AlertDescription>The goal has been reached in @_moveCount moves!</AlertDescription>
</Alert>

<div class="row">
    <div class="col" style="max-width: @(MAP_WIDTH * TILE_SIZE)px" @onclick="OnTileClicked" @onmousemove="OnTileHovered">
        <BECanvas Width="@(MAP_WIDTH * TILE_SIZE)" Height="@(MAP_HEIGHT * TILE_SIZE)" @ref="_canvasReference"></BECanvas>
    </div>

    <div class="overflow-auto col border-start ms-3" style="max-height: @(MAP_HEIGHT * TILE_SIZE)px">
        @foreach (var queueItem in Queue.OrderBy(n => n.TotalCost))
        {
            <span @onmouseenter="() => OnQueueItemEnter(queueItem.Data.X, queueItem.Data.Y)" @onmouseleave="() => OnQueueItemLeave(queueItem.Data.X, queueItem.Data.Y)">
                <label>(@queueItem.Data.X, @queueItem.Data.Y) f: @queueItem.TotalCost</label>
                <small>&nbsp;&nbsp;<i>g: @queueItem.PathCost + h: @queueItem.HeuristicCost</i></small>
            </span>
            <br />
        }
    </div>
</div>



<div class="row">
    <div class="col">
        <button class="btn btn-outline-primary" @onclick="OnResetClicked">Reset</button>
        <button class="btn btn-outline-primary" @onclick="OnSetStartClicked">Set Start</button>
        <button class="btn btn-outline-primary" @onclick="OnSetGoalClicked">Set Goal</button>
        <button class="btn btn-outline-primary" @onclick="OnRunClicked">Run</button>
        <button class="btn btn-outline-primary" @onclick="OnStepClicked">Step</button>
    </div>
</div>

<div class="row">
    <div class="col">
        <label>@Status</label>
        <br />
        <textarea readonly rows="6">@TileInformation</textarea>
    </div>
</div>


@code {
    private const int TILE_SIZE = 24;
    private const int MAP_WIDTH = 20;
    private const int MAP_HEIGHT = 20;

    private const string STYLE_START = "red";
    private const string STYLE_GOAL = "green";

    private const string STYLE_PASSABLE = "ghostwhite";
    private const string STYLE_WALL = "blue";

    private const string STYLE_FRONTIER = "yellow";
    private const string STYLE_NEXT = "orange";
    private const string STYLE_EXPANDED = "darkgoldenrod";

    private const string STYLE_HOVERED = "cornflowerblue";


    private bool _settingStart;
    private bool _settingGoal;


    public string TileInformation { get; set; } = "";
    public List<TreeNode<Tile>> Queue { get; set; } = new List<TreeNode<Tile>>();
    public string Status { get; set; } = "";
    public bool GoalReached 
    {
        get => _aStar != null && _aStar.GoalReached;
        set { }
    }

    private int _moveCount;


    private Canvas2DContext _context;
    protected BECanvasComponent _canvasReference;

    private World.Map _map;

    private (int x, int y) _start = (-1, -1);
    private (int x, int y) _goal = (-1, -1);

    private Pathing.AStar<World.Tile>? _aStar;

    private StringBuilder _informationBuilder = new StringBuilder();


    private void OnRunClicked()
    {
        RecreateAStar();

        while (_aStar != null && !_aStar.GoalReached)
        {
            StepAStar();
        }
    }

    private void OnStepClicked()
    {
        RecreateAStar();
        StepAStar();
    }

    private void RecreateAStar()
    {
        if(_aStar == null && _start.x != -1 && _start.y != -1 && _goal.x != -1 && _goal.y != -1)
        {
            _aStar = new Pathing.AStar<World.Tile>(_map.Heuristic, _map.ExpandTile, _map.GetTileAt(_start.x, _start.y), _map.GetTileAt(_goal.x, _goal.y));
        }
    }

    private void StepAStar()
    {
        if(_aStar == null || _aStar.GoalReached)
        {
            return;
        }

        var nextTile = _aStar.CurrentState.Next?.Data;
        if(nextTile != null)
        {
            _map.GetTileAt(nextTile.Value.X, nextTile.Value.Y).IsNext = false;
        }

        foreach (var frontierItem in _aStar.CurrentState.PriorityQueue.UnorderedItems)
        {
            var tile = frontierItem.Element.Data;
            _map.GetTileAt(tile.X, tile.Y).OnFrontier = false;
        }

        foreach (var expandedItem in _aStar.CurrentState.Expanded)
        {
            var tile = expandedItem.Data;
            _map.GetTileAt(tile.X, tile.Y).IsExpanded = false;
        }

        _aStar.Step();

        nextTile = _aStar.CurrentState.Next?.Data;
        if(nextTile != null)
        {
            _map.GetTileAt(nextTile.Value.X, nextTile.Value.Y).IsNext = true;
        }

        Queue.Clear();
        foreach (var frontierItem in _aStar.CurrentState.PriorityQueue.UnorderedItems)
        {
            var tile = frontierItem.Element.Data;
            _map.GetTileAt(tile.X, tile.Y).OnFrontier = true;

            Queue.Add(frontierItem.Element);
        }

        foreach (var expandedItem in _aStar.CurrentState.Expanded)
        {
            var tile = expandedItem.Data;
            _map.GetTileAt(tile.X, tile.Y).IsExpanded = true;
        }


        foreach(var node in _aStar.SearchTree.Nodes)
        {
            _map.GetTileAt(node.Data.X, node.Data.Y).HeuristicCost = node.HeuristicCost;
            _map.GetTileAt(node.Data.X, node.Data.Y).TotalCost = node.TotalCost;
        }

        _moveCount++;
        if(_aStar.GoalReached)
        {
            Status = $"Goal found in {_moveCount} moves!";
        }
        else
        {
            Status = $"{_moveCount} moves";
        }
        StateHasChanged();
    }

    private void OnResetClicked()
    {
        _start = (-1, -1);
        _goal = (-1, -1);
        TileInformation = "";
        Queue.Clear();
        Status = "";

        for (int x = 0; x < _map.Width; x++)
        {
            for (int y = 0; y < _map.Height; y++)
            {
                _map.GetTileAt(x, y).OnFrontier = false;
                _map.GetTileAt(x, y).IsExpanded = false;
                _map.GetTileAt(x, y).IsNext = false;
                _map.GetTileAt(x, y).TotalCost = 0;
                _map.GetTileAt(x, y).HeuristicCost = 0;
            }
        }

        _aStar = null;
    }

    private void OnSetStartClicked()
    {
        _settingStart = !_settingStart;
    }

    private void OnSetGoalClicked()
    {
        _settingGoal = !_settingGoal;
    }

    private void OnTileClicked(MouseEventArgs e)
    {
        int x = (int)(e.OffsetX / TILE_SIZE);
        int y = (int)(e.OffsetY / TILE_SIZE);

        if(x < 0 || x > MAP_WIDTH || y < 0 || y > MAP_HEIGHT)
        {
            return;
        }

        if(_settingStart)
        {
            _start = (x, y);
            _settingStart = false;
        }
        else if(_settingGoal)
        {
            _goal = (x, y);
            _settingGoal = false;
        }
        else
        {
            _map.GetTileAt(x, y).Passable = !_map.GetTileAt(x, y).Passable;
        }

        _aStar = null;
    }

    private void OnTileHovered(MouseEventArgs e)
    {
        int x = (int)(e.OffsetX / TILE_SIZE);
        int y = (int)(e.OffsetY / TILE_SIZE);

        if(x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT)
        {
            return;
        }

        var tile = _map.GetTileAt(x, y);
        _informationBuilder.Clear();
        _informationBuilder.AppendLine($"Tile @ ({x}, {y})");
        _informationBuilder.AppendLine($"Cost (f(n)): {tile.TotalCost}");
        _informationBuilder.AppendLine($"Heuristic (h(n)): {tile.HeuristicCost}");

        if (tile.IsNext)
        {
            _informationBuilder.AppendLine($"Up next");
        }
        else if(tile.IsExpanded)
        {
            _informationBuilder.AppendLine($"Expanded");
        }
        else if (tile.OnFrontier)
        {
            _informationBuilder.AppendLine($"On frontier");
        }

        TileInformation = _informationBuilder.ToString();
    }

    private void OnQueueItemEnter(int tileX, int tileY)
    {
        if (tileX < 0 || tileX >= MAP_WIDTH || tileY < 0 || tileY >= MAP_HEIGHT)
        {
            return;
        }

        _map.GetTileAt(tileX, tileY).IsHovered = true;
        var args = new MouseEventArgs()
        {
            OffsetX = tileX * TILE_SIZE,
            OffsetY = tileY * TILE_SIZE
        };
        OnTileHovered(args);
    }

    private void OnQueueItemLeave(int tileX, int tileY)
    {
        if (tileX < 0 || tileX >= MAP_WIDTH || tileY < 0 || tileY >= MAP_HEIGHT)
        {
            return;
        }

        _map.GetTileAt(tileX, tileY).IsHovered = false;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if(firstRender)
        {
            _map = new World.Map(MAP_WIDTH, MAP_HEIGHT);
        }
        this._context = await this._canvasReference.CreateCanvas2DAsync();
        await Draw();
    }

    private async Task Draw()
    {
        await this._context.SetStrokeStyleAsync("silver");
        for (int x = 0; x < _map.Width; x++)
        {
            for (int y = 0; y < _map.Height; y++)
            {
                var tile = _map.GetTileAt(x, y);

                if(tile.Passable)
                {
                    if (_start.x == x && _start.y == y)
                    {
                        await this._context.SetFillStyleAsync(STYLE_START);
                    }
                    else if (_goal.x == x && _goal.y == y)
                    {
                        await this._context.SetFillStyleAsync(STYLE_GOAL);
                    }
                    else if(tile.IsHovered)
                    {
                        await this._context.SetFillStyleAsync(STYLE_HOVERED);
                    }
                    else if (tile.IsExpanded)
                    {
                        await this._context.SetFillStyleAsync(STYLE_EXPANDED);
                    }
                    else if (tile.IsNext)
                    {
                        await this._context.SetFillStyleAsync(STYLE_NEXT);
                    }
                    else if (tile.OnFrontier)
                    {
                        await this._context.SetFillStyleAsync(STYLE_FRONTIER);
                    }
                    else
                    {
                        await this._context.SetFillStyleAsync(STYLE_PASSABLE);
                    }
                }
                else
                {
                    await this._context.SetFillStyleAsync(STYLE_WALL);
                }


                await this._context.FillRectAsync(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                await this._context.StrokeRectAsync(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }
    }
}